// *********************************************************************
// Generated by JagStudio
// Based on BCX32 - BASIC To C/C++ Translator (V) 6.00 (2009/06/02)
//                 BCX (c) 1999 - 2009 by Kevin Diggins
//              Translated for compiling with a C Compiler
// *********************************************************************
// *********************************************************************

// ***************************************************
// Compiler Defines
// ***************************************************

// C++
#if defined( __cplusplus )
  #define overloaded
  #define C_EXPORT EXTERN_C __declspec(dllexport)
  #define C_IMPORT EXTERN_C __declspec(dllimport)
#else
  #define C_EXPORT __declspec(dllexport)
  #define C_IMPORT __declspec(dllimport)
#endif

#include "jstudio.h"
#include "romassets.h"
#define UINT unsigned int
#define WORD short
#define BYTE char
#define UWORD unsigned short
#define UBYTE unsigned char
//Lines inserted deliberately because of some bcx brokeness - fix at some point!
//Lines inserted deliberately because of some bcx brokeness - fix at some point!
//Lines inserted deliberately because of some bcx brokeness - fix at some point!
#define peek(x) (*(volatile char *)(x))
#define dpeek(x) (*(volatile short *)(x))
#define lpeek(x) (*(volatile int *)(x))
// *************************************************
//               Standard Prototypes
// *************************************************
char*   BCX_TmpStr(size_t);
char*   join (int, ... );
float   rnd (void);
// *************************************************
//            User Global Initialized Arrays
// *************************************************

// *************************************************
//            User Defined Constants
// *************************************************

#define sprParticleLayer 0
#define spriteStart 1
#define spriteEnd 30

// *************************************************
//                System Variables
// *************************************************


// *************************************************
//            User Global Variables
// *************************************************

static int     i;
static int     collisionSprAddr;
static int     collisionSprIndex;
static int     globalCollision;


// *************************************************
//                  Main Program
// *************************************************

void basicmain()
{
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 11] const sprParticleLayer% = 0
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 12] const spriteStart   = 1
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 13] const spriteEnd   = 30
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 16] jsfSetFontIndx(1)
jsfSetFontIndx(1);
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 17] jsfSetFontSize(1)
jsfSetFontSize(1);
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 20] rapLocate 100,202
rapLocate(100,202);
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 21] rapPrint "Collision List"
js_r_textbuffer=(char *)"Collision List";
rapPrint();
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 24] DIM i AS INTEGER
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 25] DIM collisionSprAddr as integer
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 26] DIM collisionSprIndex as integer
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 27] DIM globalCollision AS INTEGER
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 30] FOR i = spriteStart TO spriteEnd
for(i=spriteStart; i<=spriteEnd; i+=1)
  {
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 32] sprite[i].active = R_is_active
    sprite[i].active=R_is_active;
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 33] sprite[i].x_ = rapRND() & 255
    sprite[i].x_=rapRND()&255;
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 34] sprite[i].y_ = rapRND() & 255
    sprite[i].y_=rapRND()&255;
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 35] sprite[i].xadd = (rnd * (4<<16)) - (rnd * (4<<16))
    sprite[i].xadd=(rnd()*(4<<16))-(rnd()*(4<<16));
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 36] sprite[i].yadd = (rnd * (4<<16)) - (rnd * (4<<16))
    sprite[i].yadd=(rnd()*(4<<16))-(rnd()*(4<<16));
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 37] sprite[i].colchk = R_can_hit
    sprite[i].colchk=R_can_hit;
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 39] NEXT i
  }
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 43] Do
for(;;)
  {
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 45] globalCollision = rapCollide(spriteStart,spriteEnd,spriteStart,spriteEnd)
    globalCollision=rapCollide(spriteStart,spriteEnd,spriteStart,spriteEnd);
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 46] if globalCollision > -1 then
    if(globalCollision>-1)
      {
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 48] i = 0
        i=0;
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 49] DO
        for(;;)
          {
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 51] collisionSprAddr = colliders[i].objectHitAddr
            collisionSprAddr=colliders[i].objectHitAddr;
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 52] if collisionSprAddr > -1 then
            if(collisionSprAddr>-1)
              {
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 54] collisionSprIndex = jsfGetSpriteIndex(collisionSprAddr)
                collisionSprIndex=jsfGetSpriteIndex(collisionSprAddr);
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 56] if sprite[collisionSprIndex].curframe = 0 then
                if(sprite[collisionSprIndex].curframe==0)
                  {
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 58] sprite[collisionSprIndex].curframe = 9
                    sprite[collisionSprIndex].curframe=9;
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 59] sprite[collisionSprIndex].xadd_ = (rapRND() & 3) - (rapRND() & 3)
                    sprite[collisionSprIndex].xadd_=(rapRND()&3)-(rapRND()&3);
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 60] sprite[collisionSprIndex].yadd_ = (rapRND() & 3) - (rapRND() & 3)
                    sprite[collisionSprIndex].yadd_=(rapRND()&3)-(rapRND()&3);
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 61] endif
                  }
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 63] endif
              }
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 64] i++
            i++;
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 66] LOOP UNTIL collisionSprAddr < 0
            if(collisionSprAddr<0)
              {
                break;
              }
          }
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 68] endif
      }
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 70] VSYNC
    jsfVsync(0);
// [F:\Jaguar\Tools\JagStudio\projects\basic\collisionlist\collisionlist.bas - 72] LOOP
  }
  while(1) {};   //  End of main program
}

// *************************************************
//                 Runtime Functions
// *************************************************

char BCX_TmpStr_buffer[256];
char *BCX_TmpStr (size_t Bites)
{
  BCX_TmpStr_buffer[Bites]=0;
  return &BCX_TmpStr_buffer[0]; //that's all you're gonna get ;)
//  static int   StrCnt;
//  static char *StrFunc[2048];
//  StrCnt=(StrCnt + 1) & 2047;
//  if(StrFunc[StrCnt]) free (StrFunc[StrCnt]);
//  return StrFunc[StrCnt]=(char*)calloc(Bites+128,sizeof(char));
}


char * join(int n, ...)
{
  register int i = n, tmplen = 0;
  register char *s_;
  register char *strtmp;
  va_list marker;
  va_start(marker, n); // Initialize variable arguments
  while(i-- > 0)
  {
    s_ = va_arg(marker, char *);
    if(s_) tmplen += strlen(s_);
  }
  strtmp = BCX_TmpStr(tmplen);
  va_end(marker); // Reset variable arguments
  i = n;
  va_start(marker, n); // Initialize variable arguments
  while(i-- > 0)
  {
    s_ = va_arg(marker, char *);
    if(s_) strcat(strtmp, s_);
  }
  va_end(marker); // Reset variable arguments
  return strtmp;
}


float rnd (void)
{
  return (float)rand()/RAND_MAX;
}


